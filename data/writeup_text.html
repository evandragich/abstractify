<h4>
  Introduction
  </h4>
  <p> Everyone has the ability to express themselves through art, but some of us lack the technical skills to create an aesthetically-pleasing piece. Novice artists can use paint-by-numbers as an elegant solution - one can practice their artistic skills while still creating something that elicits pride. Unfortunately, paint-by-numbers has a major flaw - the need to use someone else’s template restricts the imagination of the artist and limits the possible subjects that one can create. What if an artist could choose their own image and transform it into a personal paint-by-numbers kit with a set number of colors and an outline? Our project attempts to answer this question in the form of a Shiny Application which takes as input an image file from the user. From there, it simplifies the image into a user-selected number of distinct colors and outputs the abstract image, the image  outline, color analytics, and custom color palettes.
In order to showcase our color palette, we use visualizations constructed from three datasets used previously in the course: the YouGov `brexit.csv` survey results, the `BA_degrees` awards data, and the TidyTuesday `dog_travel.csv` dog adoption figures. In each of these datasets, we use the same variables and plot types as the class has used in past homeworks.  As sample images, we have included four head shots of our team, an abstract art piece, and a Simpsons image.
</p>
<h4>
  Image Processing
</h4>
<p>
Paint-by-numbers was invented in the early 1950s and relied upon very abstract art styles that required few distinct colors.. As the public became more demanding - seeking templates for famous pieces and more realistic styles - the color requirements began to grow as well. Even today,  paint-by-number kits struggle to show both high levels of detail and realistic low-contrast color shifts in the same kit without an unwieldy number of distinct shades. Our application approaches the paint-by-numbers process with color minimization as a priority - the number of desired colors is a user-input and has a maximum of ten. Our choice to minimize colors means that our application cannot preserve all of the fine detail in realistic images and thus creates a more abstract version of the original.

  </p>
<h4>
  Color Simplification
</h4>
<p>
  In order to reduce the image to the selected number of colors, we employ k-means clustering to find the most significant colors in the image. The `colordistance` package includes a helpful wrapper function, `getKMeanColors`, that tailors base R’s `kMeansCluster` function for clustering pixels. The extractClusters function  then operates on the k-means object and returns a dataframe wherein each row is a color cluster with the RGB values, the size of the cluster, and the nearest named color. By matching the information on our clusters with positions from the original image , we create the abstract image and display it for the user. While we are able to make heavy use of `colordistance` to simplify the colors of an image, the process of creating the outlines is done through our own set of functions.

</p>
<h4>
  Outline Creation
</h4>
<p>
  Outline creation is performed via the `outline_func` and `plot_outline` functions. The former is given the k-means color cluster object from earlier and the pixel dimensions of the original image. From there, `outline_func` transforms the cluster vector into a matrix with the original’s dimensions. `plot_outline` operates on this matrix differently depending on size - small images that lack fine detail are essentially rounded to either black or white. Larger images are passed to a more extensive `boundary_func` function that iterates through each pixel. If the pixel next to a pixel from a different color cluster, it is colored black to denote a boundary between distinct colors. Otherwise, each pixel is white.

</p>
<h4>
  Color Analytics
</h4>
<p>
  Our Color Palette Info tab contains three figures of interest - a Colorspace plot of the original image’s RGB values in 3D, a reactive table with the clustered colors, and an R-Squared figure for the simplification process. The RGB figure is constructed via the colordistance wrapper function `plotPixels` applied to the original image. Diagnostically, the RGB plot allows us to see the distribution of color in the original image and offers insight into how many clusters are required to adequately process the original. Contrastingly, the reactive table shows the color palette after our simplification process. The R-squared value is the link between the two and serves as a metric of how well the original image’s colors are captured by the chosen number of clusters. Increasing the number of clusters will always increase R-Squared, but there are diminishing returns and performance losses for doing so. Our example images are best simplified with a minimum of three colors, but show only small improvements for using more than six distinct hues.

</p>
<h4>
  Custom Palettes & Example Visualizations
</h4>
<p>
  In this tab, users can visualize the set of extracted colors in various sample plots and compare to commonly used packages for color palettes in R. The header of this page displays the selected hex codes separated by quotation marks and commas for easy insertion into a color or fill scale in ggplot. There is also a button to copy this text to the clipboard directly. The body of this page contains a series of similar plots, each only differing by color palette. Users can click the radio buttons to toggle through three plots, each labeled by the type of color scale most appropriate for visualizing the data: “Discrete", "Sequential", and "Diverging." For sequential and diverging plots, users also have the option to choose which colors from the palette should represent the low and high ends of the color scale on the plot. The default values for these ends are the lightest and darkest hex codes from the extracted palette, respectively, as determined by the sum of the RGB components. For sequential plots, they can also adjust the darkness of the gray “Other” category. After manipulating these values, users can compare the generated plot against the default palettes from commonly used color packages in R. For all plots, these include base ggplot2 colors, the RColorBrewer package, and the colorspace package. The viridis package is also displayed only for categorical and sequential plots, as there is no default diverging color scale from the viridis package.
	The content of the plots is a throwback to various homework assignments for this course. Specifically, the categorical plot is a modified version of homework 4, question 1 ("Degrees over time"), the sequential plot is a recreation of homework 3, question 4 ("Adopt, don’t shop"),  and the diverging plot is a recreation of the first plot of the composition from homework 4, question 5 ("Brexit"). We chose these plots to allow our primary users - our classmates in this course, who are familiar with these data - to focus on the color scale and visual components as they browse the plots, rather than spend significant time making sense of the data and its context.

</p>
<h4>
  Discussion
</h4>
<p>
  We were originally inspired to create our application by paint-by-numbers, but as the project developed we began to see the difficulty of creating image outlines that could actually be filled by a human - often, the drawn regions are so small and numerous that a number couldn’t even be displayed in all of them. We have identified three common features in an image that can produce poor simplifications and outlines: overall lack of contrast, fractal-like patterns, and blur effects. Low contrast reduces the effectiveness of our k-means fitting while fractal patterns such as tree branches produce unfillable templates. Blur effects naturally reduce the information available to our application while also weakening the color changes that trigger boundaries to be drawn.
	Aside from specific patterns, our application is also severely limited by image size - processing time and RAM needs increase rapidly as the resolution of the user image rises. In order to cap runtimes to a reasonable level, we recommend using images that are less than 200KB.
	The final limitation of our application is that it does not produce its outlines deterministically. Each time that one varies the number of distinct colors on a small image, the simple boundary function will return outlines with significant changes. On large images, however, the outlines are much more stable and tend to emphasize the same features in the original image.

</p>
